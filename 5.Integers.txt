Представление целых чисел

В вычислениях нет возможности представить произвольное (бесконечное) целое число - целые числа всегда конечны из-за ограничения оборудования. Целочисленная арифметика реализованная в центральном процессоре обычно используется для работы с целыми числами определенной разрядности, которая зависит от разрядности процессора. Большая часть современных процессоров имеют 64-битные регистры и нативно могут работать с 64-битными числами, некоторые процессоры (в частности Intel-совместимые) так же имеют более короткие регистры - 8, 16, 32 битные, умеют работать с широкими (сдвоенными) регистрами, что позволяет реализовать 128, 256, и 512-битные операции (технологии SIMD SSE2/AVX) и поддерживают векторные операции, которые упрощают работу с более длинными числами (Large Integer Arythmetics), однако фактически сложность работы с такими числами будет зависеть от длины числа. Не все аппаратные наборы инструкций, особенно для длинных чисел поддерживают операцию деления, иногда она реализуется программно.

Высокопроизводительная работа с целыми типами, в т.ч. векторными так же возможна с использованием графических акселераторов.

В оперативной памяти числа (как и любые другие данные) занимают определенное количество байт, при этом никакие операции в самой памяти невозможны - значение из памяти переносится в регистр процессора, и уже там над ним возможны операции.

В некоторых языках реализован тип (иногда называемый BIGINT) имеющий переменную разрядность и способный хранить очень большие числа. 
В частности, python 3 умеет автоматически выбирать длину числа практически до бесконечности (в пределах доступной памяти), что позволяет работать с целочисленными значениями используя привычную арифметику.

В C и C++ стандартно реализованы только целые типы фиксированной длины. 

Работа с целым типом фиксированной длины внутри процессора имеет свои особенности, арифметика таких чисел отличается от привычной и фактически представляет из себя работу с кольцевым множеством. Проще всего представить кольцевое множество в виде циферблата часов с одной стрелкой и цифрами от 0 до (2^n)-1 где n - разрядность числа. Операции сложения и вычитания соответствуют движению стрелки по часовой / против часово стрелки, при этом стрелка может свободно проходить через 0.

Проиллюстрируем на примере 4х битных целых чисел (на практике таких не бывает, потому что не существует 4х битных регистров)

Все возможные значения для 4х бит это 0, 1, 2, ..., 15 (представьте циферблат с числами от 0 до 15, где 0 это полдень и он же полночь).

Фактически, операции производятся по модулю 16 (2 в степени n, где n количество бит). Значение 16 это тоже что 0.

2 + 2 = 4
15 + 1 = 0
8 + 9 = 1
11 + 15 = 10

Знаковое и беззнаковое представление:

В примере выше можно заметить, что прибавление 15  к любому числу уменьшает его значение на 1.
Фактически в операциях сложения и вычитания 15 может выполнять роль -1 (без часу полдень/полночь).
В общем случае число (2^n - x) может выполнять роль -x из-за того что 2^n соответствует полному обороту стрелки циферблата и два значения отличающиеся на 2^n не различимы. В нашем примере для 15 n=4 и x=1.
Такое представление отрицательных чисел называется дополненным. Оно позволяет использовать одинаковую арифметику для сложения и вычитания положительных и отрицательных чисел (для умножения и деления это уже не проходит и знак должен учитываться).

В C/C++ (и большинстве других языков программирование) целое число может быть описано как знаковое или как беззнаковое. Например в нашем примере 4х битных чисел мы можем интерпретировать значения как беззнаковые (0, 1, 2, ..., 15) или как знаковые (-8, -7, ..., -1, 0, 1, ..., 7). В общем случае для целых чисел разрядности n беззнаковое представление дает диапазон 0 .. (2^n)-1, знаковое представление -2^(n-1) .. (2^(n-1) - 1 (положительных чисел на одно меньше т.к. 0 так же не имеет знака).

При этом если записать число в двоичном виде, то старший разряд у отрицательных чисел будет 1, что позволяет рассматривать этот разряд как знаковый. В нашем 4х битном примере

Двоичная	Знаковое	беззнаковое
Запись		значение	значение
0000		 0		0
0001		+1		1
...
0111		+7		7
1000		-8		8
1001		-7		9
...
1111		-1		15

Умножение на -1 в дополненном представлении соответствует инверсии всех бит в двоичной записи числа и добавлении 1 к полученному значению (не достаточно инвертировать только знаковый бит). Например +7 это 0111. Инвертировав биты, получаем 1000. Добавив 1 получаем 1001 (-7).

Обратите внимание, что в знаковом представлении при прибавлении 1 к максимальному положительному числу (в примере +7) получится максимальное отрицательное (-8). В беззнаковой арифметике при прибавлении 1 к максимальному числу (15) получится 0.

Целые типы в C/C++

Базовые типы

Для базовых типов не определена их длина в битах, но даются определенные гарантии относительно нее:

Знаковые        Беззнаковые
char		unsigned char			не менее 8 бит
short		unsigned short			не мнее 16 бит
int		unsigned			не менее short
long		unsigned long			не менее 32 бит
long long	unsigned long long   		не менее 64 бит

(unsigned) long long только в стандарте C99 (не все компиляторы совместимы, в частности старые компиляторы Microsoft)

Так же могут использоваться специальные целые типы, такие как size_t (используется для указания размера буфера в памяти и соответствует разрядности адресного пространства)

Следует использовать 
char / unsigned char для хранения ASCII символов
int / unsigned int для общих целых чисел без особых требований к диапазону, например для цикловых итераторов в циклах с небольшим количеством итераций
Остальные типы использовать не следует без особых причин.

Не следует экономить в размерах типа для целочисленных переменных, используйте тип int даже для небольших значений - для него выбирается разрядность соответствующая "родной" разрядности регистров процессоров и работа с ним будет наиболее эффективной. Имеет смысл экономить память только на больших массивах.

При необходимости использовать типы гарантированной разрядности используйте типы с явным указанием длины (stdint). Для использования этих типов необходимо включение файла stdint.h
#include <stdint.h>, они поддерживаются в C99 и выше.

Знаковые	Беззнаковые
int8_t		uint8_t
int16_t		uint16_t
int32_t		uint32_t
int64_t		uint64_t

Некоторые компиляторы могут поддерживать типы большей длины (например uint128_t).

Поддержка целочисленных типов может быть ограничена платформой или может накладывать дополнительные ограничения на их расположения в памяти. Например на процессорах ARM эффективность работы с целыми типами будет снижаться, если разрядность числа отличается от разрядности архитектуры или значение расположено не по адресу, кратному количеству байт в числе, т.к. такие операции не поддерживаются процессором и эмулируются в языке через несколько операций, в которых задействовано несколько регистров процессора и битовая арифметика.

Порядок байт:

Если в числе более 8 бит, то при нахождении в памяти оно будет занимать несколько байт. Фактически запись числа по байтам соответствует 256-ричному представлению числа. Например для 4х байт (32 бит) значения байт ABCD соответствует (беззнаковому) числу A*256^3 + B*256^2 + C*256 + D. При этом есть важный вопрос: как именно байты числа будут располагаться в адресном пространстве. В настоящее время встречается два варианта: по младшему адресу памяти будет расположен старший бат (A, B, C, D) - такой порядок называется Big endian, или по младшему адресу будет располагаться младший байт (D, C, B, A) - такой порядок называется Little endian. In English порядок байт обозначается словом endianness ("конечность"). Название пришло из "Путешествий Гулливера" Джонатана Свифта. "Big endians" и "Little endians" в русском переводе "тупоконечники" и "острокончники", конфликтовали из-за конца, с которого следует разбивать куриные яйца. Исторически были и другие варианты, например Big endian внутри 16-битных последовательностей и Little endian для 16-битных последовательностей (C, D, A, B), но к настоящему времени они вымерли. В настоящее время чаще встречается little endian представление.

Порядок байт важен при переносе или передаче двоичных данных между различными системами, например через внешний носитель или по сети.

Разрядность и знаковость числа в программировании можно выбрать за счет выбора целого типа данных. Порядок байт является свойством используемой платформы (типа процессора и операционной системы), например процессоры ARM могут работать в обоих режимах, и порядок байт определяется при загрузке операционной системы. Существуют две версии Linux отличающиеся только порядком байт.


Типичные ошибки при работе с целыми типами в C/C++:

1. Переполнение целого типа - арифметические операции сложения, вычитания и умножения над целыми числами могут привести к переполнению (overflow) или "недополнению" (underflow) целого типа - когда стрелка циферблата проходит через 0 по часовой или против часовой стрелки соответственно. В большинстве случаев это нежелательный эффект, приводящий к ошибкам. Большая часть проблем с безопасностью двоичных приложений в настоящее время связана именно с наличием целочисленных переполнений в коде. До или после операций с целыми числами обязателен контроль диапазона значений.

Стандарты C/C++ не гарантируют какого-либо конкретного поведения в случае переполнения целого типа, и результат в общем случае не определен, однако на практике обычно происходит закольцовывание, как описано выше.

2. Проблема знаково-беззнаковых преобразований. Можно иллюстрировать таким примером, который выведет "Oooops"
#include <stdio.h>
int main(){
    unsigned u=1000000000;
    if(u > -1) printf("u > -1\n");
    else printf("Oooops\n");    
    return 0;
}
В данном случае два операнда операции сравнения будут приведены к одному типу (unsigned) и -1 будет интерпретировано как UNSIGNED_MAX.

3. Деление на ноль в целых числах вызывает аппаратное событие, которое приводит к исключительной ситуации (exception) и обычно приводит к аварийному завершению программы. Перед операцией деления надо исключить ситуацию, когда делитель может быть нулем.

4. Результат операций над целыми типами в C - это целое число. Например, результат выражения (2/3)*6 это 0, т.к. 2/3 это 0 в целых числах (что может быть неожиданным эффектом).


Как определять/избегать переполнения:

Единого красивого способа в C/C++ пока нет.

Варианты:

1. Ограничивать диапазон операнда (по модулю), например для сложения и вычитания - половина от максимального значения (например для int INT_MAX/2) для умножения - корень из максимального значения (например приблизительно взятый как (INT_MAX>>(sizeof(INT_MAX)*4)))
2. Проверять значения, например для сложения положительных a и b что a <= INT_MAX-b, для умножения что a < INT_MAX/b
3. В стандарте C23 (2024го года) / С++26 (в разработке) можно использовать макросы ckd_add, ckd_sub, ckd_mul для сложения, вычитания, умножения соответственно. Макрос выполняет операцию и возвращает признак переполнения. Стандарт новый, поэтому в настоящее время практически нигде не реализован
4. В некоторых компиляторах (GCC, Clang) уже есть макросы __builtin_add_overflow, __builtin_sub_overflow, __builtin_mul_overflow выполняющие аналогичную функцию, но не являющиеся стандартными
